{"ast":null,"code":"import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { style } from '../render/dom/style.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { hydrateKeyframes } from './keyframes/hydrate.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\nconst animationMaps = new WeakMap();\nconst animationMapKey = (name, pseudoElement) => \"\".concat(name, \":\").concat(pseudoElement);\nfunction getAnimationMap(element) {\n  const map = animationMaps.get(element) || new Map();\n  animationMaps.set(element, map);\n  return map;\n}\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation {\n  constructor(options) {\n    /**\n     * If we already have an animation, we don't need to instantiate one\n     * and can just use this as a controls interface.\n     */\n    if (\"animation\" in options) {\n      this.animation = options.animation;\n      return;\n    }\n    const {\n      element,\n      name,\n      keyframes: unresolvedKeyframes,\n      pseudoElement,\n      allowFlatten = false\n    } = options;\n    let {\n      transition\n    } = options;\n    this.isPseudoElement = Boolean(pseudoElement);\n    this.allowFlatten = allowFlatten;\n    /**\n     * Stop any existing animations on the element before reading existing keyframes.\n     *\n     * TODO: Check for VisualElement before using animation state. This is a fallback\n     * for mini animate(). Do this when implementing NativeAnimationExtended.\n     */\n    const animationMap = getAnimationMap(element);\n    const key = animationMapKey(name, pseudoElement || \"\");\n    const currentAnimation = animationMap.get(key);\n    currentAnimation && currentAnimation.stop();\n    /**\n     * TODO: If these keyframes aren't correctly hydrated then we want to throw\n     * run an instant animation.\n     */\n    const keyframes = hydrateKeyframes(element, name, unresolvedKeyframes, pseudoElement);\n    invariant(typeof transition.type !== \"string\", \"animateMini doesn't support \\\"type\\\" as a string. Did you mean to import { spring } from \\\"motion\\\"?\");\n    transition = applyGeneratorOptions(transition);\n    this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n    if (transition.autoplay === false) {\n      this.animation.pause();\n    }\n    this.removeAnimation = () => animationMap.delete(key);\n    this.animation.onfinish = () => {\n      if (!pseudoElement) {\n        style.set(element, name, getFinalKeyframe(keyframes, transition));\n        this.cancel();\n      }\n    };\n    /**\n     * TODO: Check for VisualElement before using animation state.\n     */\n    animationMap.set(key, this);\n  }\n  play() {\n    this.animation.play();\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.finish();\n  }\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch (e) {}\n    this.removeAnimation();\n  }\n  stop() {\n    const {\n      state\n    } = this;\n    if (state === \"idle\" || state === \"finished\") {\n      return;\n    }\n    this.commitStyles();\n    this.cancel();\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * In this method, we commit styles back to the DOM before cancelling\n   * the animation.\n   *\n   * This is designed to be overridden by NativeAnimationExtended, which\n   * will create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to also correctly calculate velocity for any subsequent animation\n   * while deferring the commit until the next animation frame.\n   */\n  commitStyles() {\n    if (!this.isPseudoElement) {\n      var _this$animation$commi, _this$animation;\n      (_this$animation$commi = (_this$animation = this.animation).commitStyles) === null || _this$animation$commi === void 0 || _this$animation$commi.call(_this$animation);\n    }\n  }\n  get duration() {\n    var _this$animation$effec;\n    const duration = ((_this$animation$effec = this.animation.effect) === null || _this$animation$effec === void 0 ? void 0 : _this$animation$effec.getComputedTiming().duration) || 0;\n    return millisecondsToSeconds(Number(duration));\n  }\n  get time() {\n    return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n  }\n  set time(newTime) {\n    this.animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  /**\n   * The playback speed of the animation.\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n   */\n  get speed() {\n    return this.animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    this.animation.playbackRate = newSpeed;\n  }\n  get state() {\n    return this.animation.playState;\n  }\n  get startTime() {\n    return Number(this.animation.startTime);\n  }\n  get finished() {\n    return this.animation.finished;\n  }\n  flatten() {\n    if (this.allowFlatten) {\n      var _this$animation$effec2;\n      (_this$animation$effec2 = this.animation.effect) === null || _this$animation$effec2 === void 0 || _this$animation$effec2.updateTiming({\n        easing: \"linear\"\n      });\n    }\n  }\n  /**\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n   */\n  attachTimeline(timeline) {\n    this.animation.timeline = timeline;\n    this.animation.onfinish = null;\n    return noop;\n  }\n  /**\n   * Allows the animation to be awaited.\n   *\n   * @deprecated Use `finished` instead.\n   */\n  then(onResolve, onReject) {\n    return this.finished.then(onResolve).catch(onReject);\n  }\n}\nexport { NativeAnimation };","map":{"version":3,"names":["invariant","millisecondsToSeconds","secondsToMilliseconds","noop","style","getFinalKeyframe","hydrateKeyframes","startWaapiAnimation","applyGeneratorOptions","animationMaps","WeakMap","animationMapKey","name","pseudoElement","concat","getAnimationMap","element","map","get","Map","set","NativeAnimation","constructor","options","animation","keyframes","unresolvedKeyframes","allowFlatten","transition","isPseudoElement","Boolean","animationMap","key","currentAnimation","stop","type","autoplay","pause","removeAnimation","delete","onfinish","cancel","play","complete","finish","e","state","commitStyles","_this$animation$commi","_this$animation","call","duration","_this$animation$effec","effect","getComputedTiming","Number","time","currentTime","newTime","speed","playbackRate","newSpeed","playState","startTime","finished","flatten","_this$animation$effec2","updateTiming","easing","attachTimeline","timeline","then","onResolve","onReject","catch"],"sources":["C:/Users/admin/node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs"],"sourcesContent":["import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { style } from '../render/dom/style.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { hydrateKeyframes } from './keyframes/hydrate.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\nconst animationMaps = new WeakMap();\nconst animationMapKey = (name, pseudoElement) => `${name}:${pseudoElement}`;\nfunction getAnimationMap(element) {\n    const map = animationMaps.get(element) || new Map();\n    animationMaps.set(element, map);\n    return map;\n}\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation {\n    constructor(options) {\n        /**\n         * If we already have an animation, we don't need to instantiate one\n         * and can just use this as a controls interface.\n         */\n        if (\"animation\" in options) {\n            this.animation = options.animation;\n            return;\n        }\n        const { element, name, keyframes: unresolvedKeyframes, pseudoElement, allowFlatten = false, } = options;\n        let { transition } = options;\n        this.isPseudoElement = Boolean(pseudoElement);\n        this.allowFlatten = allowFlatten;\n        /**\n         * Stop any existing animations on the element before reading existing keyframes.\n         *\n         * TODO: Check for VisualElement before using animation state. This is a fallback\n         * for mini animate(). Do this when implementing NativeAnimationExtended.\n         */\n        const animationMap = getAnimationMap(element);\n        const key = animationMapKey(name, pseudoElement || \"\");\n        const currentAnimation = animationMap.get(key);\n        currentAnimation && currentAnimation.stop();\n        /**\n         * TODO: If these keyframes aren't correctly hydrated then we want to throw\n         * run an instant animation.\n         */\n        const keyframes = hydrateKeyframes(element, name, unresolvedKeyframes, pseudoElement);\n        invariant(typeof transition.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"motion\"?`);\n        transition = applyGeneratorOptions(transition);\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n        if (transition.autoplay === false) {\n            this.animation.pause();\n        }\n        this.removeAnimation = () => animationMap.delete(key);\n        this.animation.onfinish = () => {\n            if (!pseudoElement) {\n                style.set(element, name, getFinalKeyframe(keyframes, transition));\n                this.cancel();\n            }\n        };\n        /**\n         * TODO: Check for VisualElement before using animation state.\n         */\n        animationMap.set(key, this);\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.finish();\n    }\n    cancel() {\n        try {\n            this.animation.cancel();\n        }\n        catch (e) { }\n        this.removeAnimation();\n    }\n    stop() {\n        const { state } = this;\n        if (state === \"idle\" || state === \"finished\") {\n            return;\n        }\n        this.commitStyles();\n        this.cancel();\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    commitStyles() {\n        if (!this.isPseudoElement) {\n            this.animation.commitStyles?.();\n        }\n    }\n    get duration() {\n        const duration = this.animation.effect?.getComputedTiming().duration || 0;\n        return millisecondsToSeconds(Number(duration));\n    }\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n    }\n    set time(newTime) {\n        this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        this.animation.playbackRate = newSpeed;\n    }\n    get state() {\n        return this.animation.playState;\n    }\n    get startTime() {\n        return Number(this.animation.startTime);\n    }\n    get finished() {\n        return this.animation.finished;\n    }\n    flatten() {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\n        }\n    }\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline(timeline) {\n        this.animation.timeline = timeline;\n        this.animation.onfinish = null;\n        return noop;\n    }\n    /**\n     * Allows the animation to be awaited.\n     *\n     * @deprecated Use `finished` instead.\n     */\n    then(onResolve, onReject) {\n        return this.finished.then(onResolve).catch(onReject);\n    }\n}\n\nexport { NativeAnimation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}